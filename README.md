# hendricks

> Protocol encoding for a new internet

## Install

Install with [npm](https://www.npmjs.com/)

```sh
$ npm i hendricks --save-dev
```

### Why

There is a movement among technologists, activists, and entrepreneurs all around the world to "decentralize" the internet. What this means in practice is turning centrally operated services into peer-to-peer protocols.

Protocols are not like services. They are difficult to upgrade and must be precisely specified. They often operate in environments where minimizing storage costs is extremely important (such as the Ethereum Virtual Machine). Protocols also need the ability to "fork". For example in the dev p2p protocol, the first byte instructs the consumer how to interpret rest of the message (if the first byte is `0x00`, interpret the remaining bytes as a `hello`, if the first byte is `0x01`, interpret the remaining bytes as a `disconnect`).

Hendricks aims to let any protocol developer create easy upgradable protocols.

Hendricks has no spec language like protobuf. Rather a specifier called [dinesh](dinesh) exists to create a JSON spec. Specifiers are split out to allow for different specs that makes different sense in different contexts (for example, languages which don't support JSON).

### Molds

The primary concept in hendricks is molds. You can think of a mold like a container that data can be placed in. Each mold has their own encoding scheme, and molds can be nested into other molds. Every schema has a single root mold.

#### 1. Fixed Molds

Fixed molds allow for fixed-length encoding. When defining a fixed mold, the length of the mold must be specified.

```js
publicKeyMold = new Fixed('publicKey', 33)
privateKeyKeyMold = new Fixed('privateKey', 32)
```

#### 2. Dynamic Molds

Dynamic molds allow for variable-length encoding. When defining a dynamic mold, the *length encoding length* is specified. For example, if a dynamic field contains data between 0 and 255 bytes, a *length encoding length* of 1 is needed. If a dynamic field contains between 0 and 256**2 bytes, a *length encoding length* of 2 is needed.

```js
nameMold = new Dynamic('name', 1) // name between 0 and 255 bytes
infoMold = new Dynamic('info', 2) // name between 0 and 255 ** 2 bytes

name.encode(new Uint8Array([1, 2, 3, 4]))
// > Uint8Array([4, 1, 2, 3, 4])

info.encode(new Uint8Array([5, 6, 7, 8, 9, 10]))
// > Uint8Array([0, 5, 6, 7, 8, 9, 10])
```

#### 3. List Molds

List molds allow for encoding arrays of data, where each element in the array is of the same mold. When defining a list mold, a *length encoding length* child mold is needed.

```js
publicKeys = new List('publicKeys', 1, publicKey) // between 0 and 255 publicKeys
```

#### 4. Dictionary Molds

Dictionary molds allow for encoding structs of data. When defining a dictionary mold, an array of molds is specified.

```js
storeDictionary = new Dictionary('store', [
  nameMold,
  publicKeysMold
])
```

#### 4. Fork/Branch Molds

Fork and branch molds are key to hendricks' ability to elegantly upgrade as well as provide

```js
storeDictionary = new Dictionary('store', [
  nameMold,
  publicKeysMold
])
```

### Length Encoding

Length is encoded using big-endian with left-padding.

## Usage

```js
const Fork = require('hendricks/lib/Fork')
const Branch = require('hendricks/lib/Branch')
const Dynamic = require('hendricks/lib/Dynamic')
const Fixed = require('hendricks/lib/Fixed')
const List = require('hendricks/lib/List')
```

## Running tests

Install dev dependencies:

```sh
$ npm i -d && npm test
```

## Contributing

Pull requests and stars are always welcome. For bugs and feature requests, [please create an issue](https://github.com/safezero/hendricks/issues)

## Author

***

* [github/---](https://github.com/---)
* [twitter/---](http://twitter.com/---)

## License

Copyright Â© 2017 []()
Licensed under the ISC license.

***

_This file was generated by [readme-generator](https://github.com/jonschlinkert/readme-generator) on May 04, 2017._
